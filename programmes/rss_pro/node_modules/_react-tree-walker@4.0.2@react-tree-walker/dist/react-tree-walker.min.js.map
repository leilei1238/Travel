{"version":3,"file":"react-tree-walker.min.js","sources":["../src/index.js"],"sourcesContent":["/* eslint-disable no-console */\n\n// Inspired by the awesome work by the Apollo team: 😘\n// https://github.com/apollographql/react-apollo/blob/master/src/getDataFromTree.ts\n//\n// This version has been adapted to be Promise based and support native Preact.\n\nconst defaultOptions = {\n  componentWillUnmount: false,\n}\n\n// Lifted from https://github.com/sindresorhus/p-reduce\n// Thanks @sindresorhus! 🙏\nconst pReduce = (iterable, reducer, initVal) =>\n  new Promise((resolve, reject) => {\n    const iterator = iterable[Symbol.iterator]()\n    let i = 0\n\n    const next = total => {\n      const el = iterator.next()\n\n      if (el.done) {\n        resolve(total)\n        return\n      }\n\n      Promise.all([total, el.value])\n        .then(value => {\n          // eslint-disable-next-line no-plusplus\n          next(reducer(value[0], value[1], i++))\n        })\n        .catch(reject)\n    }\n\n    next(initVal)\n  })\n\n// Lifted from https://github.com/sindresorhus/p-map-series\n// Thanks @sindresorhus! 🙏\nconst pMapSeries = (iterable, iterator) => {\n  const ret = []\n\n  return pReduce(iterable, (a, b, i) =>\n    Promise.resolve(iterator(b, i)).then(val => {\n      ret.push(val)\n    }),\n  ).then(() => ret)\n}\n\nconst ensureChild = child =>\n  child && typeof child.render === 'function'\n    ? ensureChild(child.render())\n    : child\n\n// Preact puts children directly on element, and React via props\nconst getChildren = element =>\n  element.props && element.props.children\n    ? element.props.children\n    : element.children ? element.children : undefined\n\n// Preact uses \"nodeName\", React uses \"type\"\nconst getType = element => element.type || element.nodeName\n\n// Preact uses \"attributes\", React uses \"props\"\nconst getProps = element => element.props || element.attributes\n\nconst isReactElement = element => !!getType(element)\n\nconst isClassComponent = Comp =>\n  Comp.prototype &&\n  (Comp.prototype.render ||\n    Comp.prototype.isReactComponent ||\n    Comp.prototype.isPureReactComponent)\n\nconst providesChildContext = instance => !!instance.getChildContext\n\n// Recurse a React Element tree, running the provided visitor against each element.\n// If a visitor call returns `false` then we will not recurse into the respective\n// elements children.\nexport default function reactTreeWalker(\n  tree,\n  visitor,\n  context,\n  options = defaultOptions,\n) {\n  return new Promise((resolve, reject) => {\n    const safeVisitor = (...args) => {\n      try {\n        return visitor(...args)\n      } catch (err) {\n        reject(err)\n      }\n      return undefined\n    }\n\n    const recursive = (currentElement, currentContext) => {\n      if (Array.isArray(currentElement)) {\n        return Promise.all(\n          currentElement.map(item => recursive(item, currentContext)),\n        )\n      }\n\n      if (!currentElement) {\n        return Promise.resolve()\n      }\n\n      if (\n        typeof currentElement === 'string' ||\n        typeof currentElement === 'number'\n      ) {\n        // Just visit these, they are leaves so we don't keep traversing.\n        safeVisitor(currentElement, null, currentContext)\n        return Promise.resolve()\n      }\n\n      if (isReactElement(currentElement)) {\n        return new Promise(innerResolve => {\n          const visitCurrentElement = (\n            render,\n            compInstance,\n            elContext,\n            childContext,\n          ) =>\n            Promise.resolve(\n              safeVisitor(\n                currentElement,\n                compInstance,\n                elContext,\n                childContext,\n              ),\n            )\n              .then(result => {\n                if (result !== false) {\n                  // A false wasn't returned so we will attempt to visit the children\n                  // for the current element.\n                  const tempChildren = render()\n                  const children = ensureChild(tempChildren)\n                  if (children) {\n                    if (Array.isArray(children)) {\n                      // If its a react Children collection we need to breadth-first\n                      // traverse each of them, and pMapSeries allows us to do a\n                      // depth-first traversal that respects Promises. Thanks @sindresorhus!\n                      return pMapSeries(\n                        children,\n                        child =>\n                          child\n                            ? recursive(child, childContext)\n                            : Promise.resolve(),\n                      )\n                        .then(innerResolve, reject)\n                        .catch(reject)\n                    }\n                    // Otherwise we pass the individual child to the next recursion.\n                    return recursive(children, childContext)\n                      .then(innerResolve, reject)\n                      .catch(reject)\n                  }\n                }\n                return undefined\n              })\n              .catch(reject)\n\n          if (typeof getType(currentElement) === 'function') {\n            const Component = getType(currentElement)\n            const props = Object.assign(\n              {},\n              Component.defaultProps,\n              getProps(currentElement),\n              // For Preact support so that the props get passed into render\n              // function.\n              {\n                children: getChildren(currentElement),\n              },\n            )\n\n            if (isClassComponent(Component)) {\n              // Class component\n              const instance = new Component(props, currentContext)\n\n              // In case the user doesn't pass these to super in the constructor\n              instance.props = instance.props || props\n              instance.context = instance.context || currentContext\n              // set the instance state to null (not undefined) if not set, to match React behaviour\n              instance.state = instance.state || null\n\n              // Make the setState synchronous.\n              instance.setState = newState => {\n                if (typeof newState === 'function') {\n                  // eslint-disable-next-line no-param-reassign\n                  newState = newState(\n                    instance.state,\n                    instance.props,\n                    instance.context,\n                  )\n                }\n                instance.state = Object.assign({}, instance.state, newState)\n              }\n\n              if (instance.componentWillMount) {\n                instance.componentWillMount()\n              }\n\n              const childContext = providesChildContext(instance)\n                ? Object.assign({}, currentContext, instance.getChildContext())\n                : currentContext\n\n              visitCurrentElement(\n                // Note: preact API also allows props and state to be referenced\n                // as arguments to the render func, so we pass them through\n                // here\n                () => instance.render(instance.props, instance.state),\n                instance,\n                currentContext,\n                childContext,\n              )\n                .then(() => {\n                  if (\n                    options.componentWillUnmount &&\n                    instance.componentWillUnmount\n                  ) {\n                    instance.componentWillUnmount()\n                  }\n                })\n                .then(innerResolve)\n            } else {\n              // Stateless Functional Component\n              visitCurrentElement(\n                () => Component(props, currentContext),\n                null,\n                currentContext,\n                currentContext,\n              ).then(innerResolve)\n            }\n          } else {\n            // A basic element, such as a dom node, string, number etc.\n            visitCurrentElement(\n              () => getChildren(currentElement),\n              null,\n              currentContext,\n              currentContext,\n            ).then(innerResolve)\n          }\n        })\n      }\n\n      // Portals\n      if (\n        currentElement.containerInfo &&\n        currentElement.children &&\n        currentElement.children.props &&\n        Array.isArray(currentElement.children.props.children)\n      ) {\n        return Promise.all(\n          currentElement.children.props.children.map(child =>\n            recursive(child, currentContext),\n          ),\n        )\n      }\n\n      return Promise.resolve()\n    }\n\n    recursive(tree, context).then(resolve, reject)\n  })\n}\n"],"names":["defaultOptions","pReduce","iterable","reducer","initVal","Promise","resolve","reject","iterator","Symbol","i","next","el","done","total","all","value","then","catch","pMapSeries","ret","a","b","push","val","ensureChild","child","render","getChildren","element","props","children","undefined","getType","type","nodeName","getProps","attributes","isReactElement","isClassComponent","Comp","prototype","isReactComponent","isPureReactComponent","providesChildContext","instance","getChildContext","reactTreeWalker","tree","visitor","context","options","safeVisitor","err","recursive","currentElement","currentContext","Array","isArray","map","item","visitCurrentElement","compInstance","elContext","childContext","result","tempChildren","innerResolve","Component","Object","assign","defaultProps","state","setState","newState","componentWillMount","componentWillUnmount","containerInfo"],"mappings":"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"}